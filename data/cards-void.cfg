//   Special credit to Phanterm for these card concepts.
//
//   Void = Aether + Entropia = Void. Crypt focus. Loves spells that
//   transport creatures to and from the crypt -- any crypt...
//
//     CARD                  |   CODE |    ART | FLAVOR |
//                           |        |        |   TEXT |
//     ----------------------+--------+--------+--------+
//     Shriequalize          |++++++++|........|        |
//     Revel Witch           |--------|--------|        |
//     Ressurect             |        |        |        |
//     Catacombs             |++++++++|--------|        |
//     Bury Alive            |++++++++|--------|        |
//     Ghost Writer          |++++++++|--------|        |
//     Vengeful Posession    |        |        |        |
//     Lost Affluent         |        |        |        |
//     Gate to Nowhere       |        |        |        |
//     Zangried, First Dead  |--------|--------|        |
//
//   Key
//
//     '      ' -+-> CODE -+-> Completely pending.
//               `-> ART -'
//
//     '......' -+-> CODE -> Sketch, or even simply a skeleton.
//               `-> ART -> **Super early** placeholder art.
//
//     '------' -+-> CODE -> Started, early WIP, absolutely not finished.
//               `-> ART -> _Complete_ placeholder art.
//
//     '++++++' -+-> CODE -> Completed, or late WIP. Subject to changes by
//               |           peers.
//               `-> ART -> Sketch???
//
//     '######' -+-> CODE -> Accomplished, or post peer review.
//               `-> ART -> Final art???

{

"Shriequalize": {
	name: "Shriequalize",
	set: "cascadence",
	rarity: 0,
	type: "spell",
	is_response: true,
	cost: 1,
	loyalty_cost: 1,
	school: "@eval [AETHER, ENTROPIA]",
	tags: ["Void"],
	portrait: "balance.png",
	rules: "Target creature's power and toughness become equal to the lowest of the two values. If Shriequalize is in your crypt, return this card to your hand after casting it and increase the cost by 1.",
	possible_targets: "all_creatures_as_possible_targets",
	on_play: "def(class game_state game, class message.play_card info) ->commands
	[
		set(creature.attack, new_val),
		set(creature.life, new_val),
		if(find(crypt, value.name='Shriequalize' and value._uuid != info.card_uuid), [
			game.crypt.erase_card(info.card),
			add(player.hand, [ lib.citadel.create_card('Shriequalize', {cost: (info.card.cost+1)}) ]),
		]) asserting game.crypt.contains(info.card)
		   where crypt=game.crypt.cards_of(player)
		   where player=game.players[info.player_index],
	] asserting info.card != null
	  asserting size(info.targets) = 1
	  where new_val=min(creature.attack, creature.life)
	  where creature=game.creature_at_loc_or_die(info.targets[0])",
	},

"Revel Witch": {
	name: "Revel Witch",
	set: "cascadence",
	rarity: 0,
	type: "creature",
	portrait: "siren.png", //   TODO custom art.
// 	artist: "artist_TODO",  //   TODO
// 	flavor_text: "flavor_text_TODO",  //   TODO
	hue_shift: 0.72,
	cost: 2,
	loyalty_cost: 1,
	school: "@eval [AETHER, ENTROPIA]",
	tags: ["Void"],
	creature: {
		game_sounds: "magic_user",
		tags: ["Human", "Witch"],
		attack: 3,
		life: 3,
		move: 1,
		passive_abilities: [{
			name: "Soul Siphon",
			rules: "Revel Witch gets +1/+1 for each creature in your crypt.",
			static_effect: "def(class game_state game, class creature creature) ->commands [
				creature.apply_static_effect('attack', deaths),
				creature.apply_static_effect('life_shield', deaths),
				// helper code for Cheat Death
				if(creature.effects_tracking['Cheat Death'], creature.add_ability_static_duration('Indestructible')),
			] where deaths=size(player.creatures_in_crypt)
			  where player=game.players[creature.controller]",
		}],
		triggered_abilities: [{
			hidden_on_card: true,
			hidden_on_creature: true,
			on_deal_damage: "def(class creature creature, class game_state game, class creature target, int damage, null|class animation.creature_attack_hint hint=null) ->commands [
				set(creature.effects_tracking['Cheat Death'], false),
			]",
			on_attacked: "def(class creature creature, class game_state game, class creature attacker, int damage) ->commands [
				set(creature.effects_tracking['Cheat Death'], false),
			]",
			on_card_played: "def(class creature creature, class game_state game, class player player, class message.play_card info) ->commands [
				if(info.card != null and info.card.type = 'spell', set(creature.effects_tracking['Cheat Death'], false)),
			]",
		}],
		activated_abilities: [{
			name: "Cheat Death",
			rules: "You may obliterate a creature in your crypt to become momentarily <i>Indestructible</i>. The effect ends after the next attack or spell.",
			cost: 0,
			once_per_turn: true,
			school: "@eval [AETHER, ENTROPIA]",
			tags: ["Void"],
			ai_value: 1.2,
			portrait: "life-flow.png",
			hue_shift: 0.188236,
			luminance_multiplier: 1.235292,
			saturation_multiplier: 1.482352,
			is_response: true,
			sound_resolve: "gameplay/spell_bless",
			possible_targets: "def(class game_state game, class creature creature, [Loc] targets) ->[Loc]|null
				if(game.players[creature.controller].creatures_in_crypt, null, [])",
			custom_reason_cannot_cast: "def(class game_state game, class creature avatar) ->null|string
				if(game.players[avatar.controller].creatures_in_crypt, null, 'No creatures in your crypt')",
			on_play: "def(class game_state game, class message.play_card info) ->commands 
			[
// TODO; animation hint
//					_text: [ sprintf('<b>%s</b> %s', target.name, 
//					           if(steal, 'obliterated from enemy crypt', 'obliterated from your crypt'))
//					       ],
// TODO; choose the card to obliterate from crypt (or enemy's!)
				game.crypt.erase_creature(target),
				set(creature.effects_tracking['Cheat Death'], true)
			] where target = if(steal, steal[0], deads[0]) asserting size(deads) > 0
			  where steal = filter(deads, value.controller != creature.controller)
			  where deads = game.players[creature.controller].creatures_in_crypt 
			  where creature = info.get_creature(game)",
		}],
	},
},

"Catacombs": {
	name: "Catacombs",
	set: "cascadence",
	type: "creature",
	is_response: false,
	cost: 1,
	rarity: 0,
	loyalty_cost: 0,
	school: "@eval [AETHER, ENTROPIA]",
	tags: ["Void"],
	portrait: "grave-stalker.png",  //   TODO custom art.
// 	artist: "artist_TODO",  //   TODO
// 	flavor_text: "flavor_text_TODO",  //   TODO
//	rules: "(See abilities)",
	ai_flags: "@eval [AI_CARD_BUILD_DEVOTION]",
	creature: {
		abilities: ["Fragile"],
		is_land: true,
		portrait: "grave-stalker.png",
		triggered_abilities: [{
			name: "Void Harvest",
			icon: 'trigger-death.png',
			rules: "If a creature dies while on this land, sacrifice Catacombs; it gives +3 mana pool while in your crypt if sacrificed.",
			on_another_creature_died: "def(class creature creature, class game_state game, class creature victim) ->commands [
				if(victim.loc = creature.loc and not victim.is_land, set(creature.sacrificed, true)),
// TODO: needs some animation for the land sacrifice
			]",
			on_die: "def(class creature creature, class game_state game) ->commands
			[[add(avatar.passive_abilities,
				[ construct('passive_ability', {
					name: 'Void Harvest',
					static_effect: q^def(class game_state game, class creature avatar) ->commands
					[ if(active, player.apply_static_effect(
						(def(class player p, map info) ->commands add(p.base_income, int <- info.amount)),
						(def(class player p, map info) ->commands add(p.base_income, -1 * (int <- info.amount))),
						{amount: 3}
					))] where active=find(
						game.crypt.lands_of(player),
						value.summon_id = '^+ creature.summon_id +q^'
					    )
					    where player=game.players[avatar.controller]^,
				})])
			] where avatar = player.creature_avatar | player <- game.players,
				player.player_index = creature.controller ]",
		}],
		passive_abilities: [{
			name: "Void Drain",
			icon: 'plus-mana.png',
			rules: "Summoner loses -1 mana pool",
				static_effect: "def(class game_state game, class creature creature) ->commands
				if(creature.summoner >= 0,
				   game.players[creature.summoner].apply_static_effect(
					(def(class player p, map info) ->commands [
						add(p.base_income, -1);
						set(p.resources, min(p.resources, p.base_income))
					]),
					(def(class player p, map info) ->commands add(p.base_income, 1)),
					{}))
				",

		}],
	},

},

"Bury Alive": {
	name: "Bury Alive",
	set: "cascadence",
	type: "spell",
	is_response: false,
	cost: 4,
	rarity: 0,
	loyalty_cost: 1,
	school: "@eval [AETHER, ENTROPIA]",
	tags: ["Void"],
	portrait: "curse.png",  //   TODO custom art.
// 	artist: "artist_TODO",  //   TODO
// 	flavor_text: "flavor_text_TODO",  //   TODO
	rules: "Destroy target creature. It returns to its owner's hand at the end of the turn.",
	ai_flags: ["@eval AI_CARD_NEVER_TARGET_FRIENDS"],
	possible_targets: "def(class game_state game, class creature avatar, [Loc] targets) ->[Loc]|null
		if(targets = [], 
			[creature.loc | creature <- game.creatures, not creature.is_building, not creature.indestructible, creature.is_valid_target(game, avatar.controller, me)])
	",
	on_play: "def(class game_state game, class message.play_card info) ->commands
	[
		set(creature.destroyed, true),
		add(game.players[info.player_index].creature_avatar.triggered_abilities,
		[ construct('triggered_ability', {
			name: 'Bury Alive',
			once: true,
			unique_id: trigger_id,
//			particle_effects for owner avatar until end of turn? // TODO
			on_end_turn: q^def(class creature avatar, class game_state game) ->commands [
				if(corpse, game.crypt.return_to_hand(corpse)),
				trigger(avatar),
			] where corpse = game.crypt.get_creature(^+ creature.summon_id + q^)
                        ^,
		  })
		]),
	] where creature = game.creature_at_loc_or_die(info.targets[0]),
	        trigger_id = generate_uuid()",
},

"Ghost Writer": {
	name: "Ghost Writer",
	set: "cascadence",
	rarity: 0,
	type: "creature",
	portrait: "mal-ravanal.png", //   TODO custom art.
// 	artist: "artist_TODO",  //   TODO
// 	flavor_text: "flavor_text_TODO",  //   TODO
	cost: 5,
	loyalty_cost: 0,
	school: "@eval [AETHER, ENTROPIA]",
	tags: ["Void"],
	creature: {
		game_sounds: "ghostly_creature",
		tags: ["Undead"],
		attack: 3,
		life: 7,
		move: 1,
		triggered_abilities: [{
			name: "Tome of the Tomb",
			icon: 'trigger-death.png',
			rules: "While Ghost Writer is in your crypt, the cost of Undead creatures is 1 less.",
			on_die: "def(class creature creature, class game_state game) ->commands
			[[add(avatar.passive_abilities,
				[ construct('passive_ability', {
					name: 'Tome of the Tomb',
//			particle_effects while a Ghost Writer is in your crypt? // TODO			
					static_effect: q^def(class game_state game, class creature avatar) ->commands
					[ if(active, player.add_static_cost_filter(
						construct('cost_filter', {
							filter_cost: 'def(class player p, class card_base card, int cost) ->int
							if(card.creature_object and (q(Undead) in card.creature_object.tags),
								max(0, cost - 1),
								cost
							)',						
						})
					))] where active=count(player.creatures_in_crypt, value.summon_id=^+ creature.summon_id +q^),
					    where player=game.players[avatar.controller]^,
				})])
			] where avatar = player.creature_avatar | player <- game.players]",
		}],
	},
},

"Zangried, the First Dead": {
	name: "Zangried, the First Dead",
	set: "cascadence",
	rarity: 3,
	type: "creature",
	portrait: "angel-of-death.png", //   TODO custom art.
// 	artist: "artist_TODO",  //   TODO
 	flavor_text: "*Cackles maniacally*",
	cost: 8,
	loyalty_cost: 2,
	school: "@eval [AETHER, ENTROPIA]",
	tags: ["Void"],
	hero: true,
	creature: {
		tags: ["Avatar", "Angel"],
		abilities: ['Cover'],
		attack: 13,
		life: 13,
		move: 1,
		triggered_abilities: [{
			name: "Omnigrave",
			icon: 'passive-generic.png',
			rules: 'Spells you cast that say "your crypt" become "any crypt".',
			on_summoned: "def(class creature creature, class game_state game) ->commands [
				if(creature.controller >= 0, add(game.players[creature.controller].omnigrave, 1))
			]",
			on_die: "def(class creature creature, class game_state game) ->commands [
				if(creature.controller >= 0, add(game.players[creature.controller].omnigrave, -1))
			]",
			on_reach_endzone: "def(class creature creature, class game_state game) ->commands [
				if(creature.controller >= 0, add(game.players[creature.controller].omnigrave, -1))
			]",
//			static_effect: "def(class game_state game, class creature creature) ->commands [
//				game.players[creature.controller].apply_static_effect(apply_fcn, remove_fcn, {})
//			] where apply_fcn = def(class player player, map m) ->commands add(player.omnigrave, 1),
//				remove_fcn = def(class player player, map m) ->commands add(player.omnigrave, -1)",
		}],
	},
},

}
